Please translate this code in c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* --- CONSTANTS & CONFIGURATION --- */
#define MAX_LINE 512
#define MAX_SYMBOLS 100
#define MAX_SYM_LEN 50
#define MAX_PRODUCTIONS 100
#define MAX_RHS 20
#define MAX_STACK 500
#define EPSILON "epsilon"
#define END_MARKER "$"

/* --- DATA STRUCTURES --- */

// Represents a set of strings (used for NonTerminals, Terminals, First, Follow)
typedef struct {
    char items[MAX_SYMBOLS][MAX_SYM_LEN];
    int count;
} StringSet;

// Represents a single grammar production: A -> X Y Z
typedef struct {
    char lhs[MAX_SYM_LEN];
    char rhs[MAX_RHS][MAX_SYM_LEN];
    int rhs_count;
} Production;

// Represents the Grammar
typedef struct {
    StringSet non_terminals;
    StringSet terminals;
    char start_symbol[MAX_SYM_LEN];
    Production productions[MAX_PRODUCTIONS];
    int prod_count;
} Grammar;

// Represents the LL1 Generator logic
typedef struct {
    StringSet first_set[MAX_SYMBOLS];  // Index corresponds to non_terminals index
    StringSet follow_set[MAX_SYMBOLS]; // Index corresponds to non_terminals index
    
    // Parsing Table: Maps (NonTerm Index, Term Index) -> Production Index (1-based)
    // -1 indicates error/empty
    int table[MAX_SYMBOLS][MAX_SYMBOLS]; 
    bool has_conflicts;
} LL1Gen;

// Tree Node for the output
typedef struct Node {
    char symbol[MAX_SYM_LEN];
    int id;
    struct Node* parent;
    struct Node* children[MAX_RHS];
    int child_count;
    int index_in_siblings; // To help find sibling ID
} Node;

// Queue for BFS (used in printing tree)
typedef struct {
    Node* items[MAX_STACK];
    int front;
    int rear;
} NodeQueue;

/* --- HELPER FUNCTIONS --- */

void error_exit(const char* msg) {
    fprintf(stderr, "Error: %s\n", msg);
    exit(1);
}

// Set operations
void set_add(StringSet* set, const char* val) {
    for (int i = 0; i < set->count; i++) {
        if (strcmp(set->items[i], val) == 0) return;
    }
    strcpy(set->items[set->count++], val);
}

bool set_contains(StringSet* set, const char* val) {
    for (int i = 0; i < set->count; i++) {
        if (strcmp(set->items[i], val) == 0) return true;
    }
    return false;
}

int get_index(StringSet* set, const char* val) {
    for (int i = 0; i < set->count; i++) {
        if (strcmp(set->items[i], val) == 0) return i;
    }
    return -1;
}

void set_union(StringSet* dest, StringSet* src) {
    for (int i = 0; i < src->count; i++) {
        set_add(dest, src->items[i]);
    }
}

// Queue operations
void init_queue(NodeQueue* q) { q->front = 0; q->rear = 0; }
void enqueue(NodeQueue* q, Node* n) { q->items[q->rear++] = n; }
Node* dequeue(NodeQueue* q) { return q->items[q->front++]; }
bool is_empty(NodeQueue* q) { return q->front == q->rear; }

/* --- GRAMMAR FUNCTIONS --- */

void load_grammar(Grammar* g, const char* filename) {
    FILE* f = fopen(filename, "r");
    if (!f) error_exit("Could not open grammar file");

    char line[MAX_LINE];
    bool reading_prods = false;
    g->prod_count = 0;
    g->non_terminals.count = 0;
    g->terminals.count = 0;

    while (fgets(line, sizeof(line), f)) {
        // Trim newline
        line[strcspn(line, "\n")] = 0;
        if (strlen(line) == 0) continue;

        if (strncmp(line, "N =", 3) == 0) {
            char* content = strchr(line, '=') + 1;
            char* token = strtok(content, " ");
            while (token) {
                set_add(&g->non_terminals, token);
                token = strtok(NULL, " ");
            }
        } else if (strncmp(line, "E =", 3) == 0) {
            char* content = strchr(line, '=') + 1;
            char* token = strtok(content, " ");
            while (token) {
                set_add(&g->terminals, token);
                token = strtok(NULL, " ");
            }
        } else if (strncmp(line, "S =", 3) == 0) {
            char* content = strchr(line, '=') + 1;
            while (*content == ' ') content++;
            strcpy(g->start_symbol, content);
        } else if (strncmp(line, "P =", 3) == 0) {
            reading_prods = true;
        } else if (reading_prods && strstr(line, "->")) {
            char* sep = strstr(line, "->");
            *sep = 0; // split string
            char* lhs = line;
            char* rhs = sep + 2;

            // Trim LHS
            while (*lhs == ' ') lhs++;
            char* end = lhs + strlen(lhs) - 1;
            while (end > lhs && *end == ' ') *end-- = 0;

            Production* p = &g->productions[g->prod_count++];
            strcpy(p->lhs, lhs);
            p->rhs_count = 0;

            char* token = strtok(rhs, " ");
            while (token) {
                strcpy(p->rhs[p->rhs_count++], token);
                token = strtok(NULL, " ");
            }
        }
    }

    // Auto-detect terminals not in E but in productions (excluding N and epsilon)
    for (int i = 0; i < g->prod_count; i++) {
        for (int j = 0; j < g->productions[i].rhs_count; j++) {
            char* sym = g->productions[i].rhs[j];
            if (strcmp(sym, EPSILON) != 0 && !set_contains(&g->non_terminals, sym)) {
                set_add(&g->terminals, sym);
            }
        }
    }
    
    // Add $ to terminals for parsing table logic
    set_add(&g->terminals, END_MARKER);
    
    fclose(f);
}

/* --- LL1 GENERATION FUNCTIONS --- */

void compute_first_seq(Grammar* g, LL1Gen* gen, char rhs[][MAX_SYM_LEN], int rhs_len, StringSet* result) {
    if (rhs_len == 0) return;

    char* symbol = rhs[0];

    if (strcmp(symbol, EPSILON) == 0) {
        set_add(result, EPSILON);
    } else if (set_contains(&g->terminals, symbol)) {
        set_add(result, symbol);
    } else if (set_contains(&g->non_terminals, symbol)) {
        int idx = get_index(&g->non_terminals, symbol);
        StringSet* first_of_sym = &gen->first_set[idx];
        
        // Add everything from FIRST(symbol) to result
        for(int k=0; k<first_of_sym->count; k++) {
            set_add(result, first_of_sym->items[k]);
        }

        // If epsilon in FIRST(symbol) and more symbols remain, recurse
        if (set_contains(first_of_sym, EPSILON) && rhs_len > 1) {
            // Remove epsilon temporarily (conceptually) for union, then recurse
            // Note: In strict set logic, we add epsilon only if all parts produce epsilon.
            // But here, if we recurse, we are effectively trying to see what comes next.
            // We just need to ensure 'result' eventually has epsilon only if the whole chain is nullable.
            
            // Re-call with rest of sequence
            // We need a temporary set for the recursive call to check nullability
             // Simplified: if epsilon is in current, we continue.
             // The simple way: Remove epsilon from current result, add result of next.
             // Note: Implementing strictly as per python logic:
             // first_result.remove('epsilon') -> done implicitly by not breaking loop if we handled sets differently, 
             // but here we just added it.
             
             // Correct logic for C translation of Python code:
             // Python: first_result.remove('epsilon'); first_result.update(...)
             // Since we use set_add which doesn't remove, we might have added epsilon.
             // We can't easily "remove" from our array-set without shifting.
             // Instead, let's just be careful. 
             // If we recurse, it means we consumed an epsilon. 
             // The final result has epsilon ONLY if the recursion adds it back.
             
             // Trick: If we are going to recurse, we shouldn't have added epsilon from this symbol yet? 
             // Actually, the Python code adds it, then removes it if len > 1.
             // Let's implement a 'remove' helper or just handle it.
             
             // Simple hack for this specific function:
             // If we are recursing, find epsilon index and decrease count (remove it), then recurse.
             for(int z=0; z<result->count; z++) {
                 if(strcmp(result->items[z], EPSILON) == 0) {
                     // Swap with last and decrease count
                     strcpy(result->items[z], result->items[result->count-1]);
                     result->count--;
                     break;
                 }
             }
             
             // Pass pointer to slice of array? No, simpler to pass new array start logic
             // We can't pass pointer arithmetic on 2D array easily. 
             // We construct a temp array or pass index.
             // Let's pass index + 1.
             // We can't change the signature easily, so let's copy the rest to a temp buffer.
             // (Inefficient but safe).
             char temp_rhs[MAX_RHS][MAX_SYM_LEN];
             for(int c=1; c<rhs_len; c++) strcpy(temp_rhs[c-1], rhs[c]);
             compute_first_seq(g, gen, temp_rhs, rhs_len - 1, result);
        }
    }
}

void generate_first(Grammar* g, LL1Gen* gen) {
    bool change = true;
    while (change) {
        change = false;
        for (int i = 0; i < g->prod_count; i++) {
            Production* p = &g->productions[i];
            int lhs_idx = get_index(&g->non_terminals, p->lhs);
            
            StringSet rhs_first; rhs_first.count = 0;
            compute_first_seq(g, gen, p->rhs, p->rhs_count, &rhs_first);
            
            int original_size = gen->first_set[lhs_idx].count;
            set_union(&gen->first_set[lhs_idx], &rhs_first);
            
            if (gen->first_set[lhs_idx].count > original_size) change = true;
        }
    }
}

void generate_follow(Grammar* g, LL1Gen* gen) {
    int start_idx = get_index(&g->non_terminals, g->start_symbol);
    set_add(&gen->follow_set[start_idx], END_MARKER);

    bool change = true;
    while (change) {
        change = false;
        for (int i = 0; i < g->prod_count; i++) {
            Production* p = &g->productions[i];
            char* lhs = p->lhs;
            int lhs_idx = get_index(&g->non_terminals, lhs);

            for (int j = 0; j < p->rhs_count; j++) {
                char* symbol = p->rhs[j];
                if (set_contains(&g->non_terminals, symbol)) {
                    int sym_idx = get_index(&g->non_terminals, symbol);
                    
                    // Beta is everything after j
                    StringSet beta_first; beta_first.count = 0;
                    // Create temp rhs for beta
                    char beta_rhs[MAX_RHS][MAX_SYM_LEN];
                    int beta_len = 0;
                    for(int k=j+1; k<p->rhs_count; k++) {
                        strcpy(beta_rhs[beta_len++], p->rhs[k]);
                    }
                    compute_first_seq(g, gen, beta_rhs, beta_len, &beta_first);

                    int original_size = gen->follow_set[sym_idx].count;

                    // Add FIRST(beta) - {epsilon}
                    bool epsilon_in_beta = false;
                    for(int k=0; k<beta_first.count; k++) {
                        if(strcmp(beta_first.items[k], EPSILON) == 0) epsilon_in_beta = true;
                        else set_add(&gen->follow_set[sym_idx], beta_first.items[k]);
                    }

                    if (beta_len == 0 || epsilon_in_beta) {
                        set_union(&gen->follow_set[sym_idx], &gen->follow_set[lhs_idx]);
                    }

                    if (gen->follow_set[sym_idx].count > original_size) change = true;
                }
            }
        }
    }
}

void build_parsing_table(Grammar* g, LL1Gen* gen) {
    // Initialize table with -1
    for(int i=0; i<MAX_SYMBOLS; i++)
        for(int j=0; j<MAX_SYMBOLS; j++)
            gen->table[i][j] = -1;
            
    gen->has_conflicts = false;

    for (int i = 0; i < g->prod_count; i++) {
        Production* p = &g->productions[i];
        int lhs_idx = get_index(&g->non_terminals, p->lhs);
        
        StringSet first_alpha; first_alpha.count = 0;
        compute_first_seq(g, gen, p->rhs, p->rhs_count, &first_alpha);
        
        bool epsilon_in_first = false;
        for(int k=0; k<first_alpha.count; k++) {
            char* terminal = first_alpha.items[k];
            if(strcmp(terminal, EPSILON) == 0) {
                epsilon_in_first = true;
                continue;
            }
            
            int term_idx = get_index(&g->terminals, terminal);
            if (term_idx == -1) continue; // Should not happen

            if (gen->table[lhs_idx][term_idx] != -1 && gen->table[lhs_idx][term_idx] != i + 1) {
                printf("  [CONFLICT] Table[%s, %s]: Prod %d vs Prod %d\n", p->lhs, terminal, gen->table[lhs_idx][term_idx], i+1);
                gen->has_conflicts = true;
            } else {
                gen->table[lhs_idx][term_idx] = i + 1;
            }
        }

        if (epsilon_in_first) {
            StringSet* follow = &gen->follow_set[lhs_idx];
            for(int k=0; k<follow->count; k++) {
                char* terminal = follow->items[k];
                int term_idx = get_index(&g->terminals, terminal);
                 if (term_idx == -1) continue;

                if (gen->table[lhs_idx][term_idx] != -1 && gen->table[lhs_idx][term_idx] != i + 1) {
                    printf("  [CONFLICT] Table[%s, %s] (via Follow): Prod %d vs Prod %d\n", p->lhs, terminal, gen->table[lhs_idx][term_idx], i+1);
                    gen->has_conflicts = true;
                } else {
                    gen->table[lhs_idx][term_idx] = i + 1;
                }
            }
        }
    }
}

/* --- PARSER --- */

// Returns dynamic array of ints (production indices), ends with -1
int* parse(Grammar* g, LL1Gen* gen, char** input_seq, int input_len) {
    // Input Stack (Simulated by index in input_seq)
    // Actually, we need to append '$' to input.
    char* input_stack[MAX_STACK];
    for(int i=0; i<input_len; i++) input_stack[i] = input_seq[i];
    input_stack[input_len] = END_MARKER;
    int input_idx = 0;

    // Working Stack
    char* work_stack[MAX_STACK];
    int work_top = 0;
    work_stack[work_top++] = END_MARKER; // Bottom
    work_stack[work_top++] = g->start_symbol; // Top

    // Output
    static int output_prods[MAX_STACK]; // Static buffer for return
    int out_count = 0;

    while (true) {
        char* top_input = input_stack[input_idx];
        char* top_work = work_stack[work_top - 1];

        if (strcmp(top_input, END_MARKER) == 0 && strcmp(top_work, END_MARKER) == 0) {
            output_prods[out_count] = -1; // Terminator
            return output_prods;
        }

        if (strcmp(top_work, top_input) == 0) {
            input_idx++;
            work_top--; // Pop
        } else {
            // It must be a non-terminal
            int nt_idx = get_index(&g->non_terminals, top_work);
            int t_idx = get_index(&g->terminals, top_input);

            if (nt_idx == -1 || t_idx == -1) {
                printf("ERROR: Invalid symbol lookup: Work=%s, Input=%s\n", top_work, top_input);
                return NULL;
            }

            int prod_idx = gen->table[nt_idx][t_idx];
            if (prod_idx == -1) {
                printf("ERROR: Syntax Error at token '%s'. Expected from '%s'\n", top_input, top_work);
                return NULL;
            }

            output_prods[out_count++] = prod_idx;
            Production* p = &g->productions[prod_idx - 1];
            
            work_top--; // Pop LHS
            
            if (strcmp(p->rhs[0], EPSILON) != 0) {
                // Push RHS in reverse
                for (int k = p->rhs_count - 1; k >= 0; k--) {
                    work_stack[work_top++] = p->rhs[k];
                }
            }
        }
    }
}

/* --- TREE BUILDER --- */

// Recursive helper that consumes the iterator (int ptr)
Node* recursive_build_tree(Grammar* g, char* symbol, int* prod_indices_iter) {
    Node* node = (Node*)malloc(sizeof(Node));
    strcpy(node->symbol, symbol);
    node->child_count = 0;
    node->parent = NULL;
    node->id = 0;
    
    if (set_contains(&g->terminals, symbol) || strcmp(symbol, EPSILON) == 0) {
        return node;
    }

    // Must be non-terminal, consume production
    int prod_idx = *prod_indices_iter;
    *prod_indices_iter = *(prod_indices_iter + 1); // Move pointer? No, array logic.
    // In C, we passed the pointer to the CURRENT position in array. 
    // We need to advance the value the pointer points to? No, pointer to current element.
    // Actually simpler: pass int* current_idx, and access array globally or pass array.
    // Let's refactor signature later. For now, assume prod_indices_iter points to current int in array.
    
    // Actually, let's fix the call:
    // We need to advance the stream. 
    // If we just dereference, we get value. We need to increment the pointer for the NEXT call.
    // BUT, recursive_build is called inside the loop.
    
    // Better signature: Node* build(..., int* prods, int* current_pos)
    return NULL; // Placeholder
}

Node* build_tree_logic(Grammar* g, char* symbol, int* prods, int* pos) {
    Node* node = (Node*)malloc(sizeof(Node));
    strcpy(node->symbol, symbol);
    node->child_count = 0;
    node->parent = NULL;

    if (set_contains(&g->terminals, symbol) || strcmp(symbol, EPSILON) == 0) {
        return node;
    }
    
    int prod_idx = prods[*pos];
    (*pos)++; // Consume
    
    Production* p = &g->productions[prod_idx - 1];
    
    if (strcmp(p->rhs[0], EPSILON) == 0) {
        Node* child = (Node*)malloc(sizeof(Node));
        strcpy(child->symbol, EPSILON);
        child->child_count = 0; 
        child->parent = node;
        node->children[node->child_count++] = child;
    } else {
        for(int i=0; i<p->rhs_count; i++) {
            Node* child = build_tree_logic(g, p->rhs[i], prods, pos);
            child->parent = node;
            node->children[node->child_count++] = child;
        }
    }
    return node;
}

void print_tree_table(Node* root) {
    // BFS to assign IDs
    NodeQueue q; init_queue(&q);
    enqueue(&q, root);
    int idx = 1;
    
    while(!is_empty(&q)) {
        Node* n = dequeue(&q);
        n->id = idx++;
        for(int i=0; i<n->child_count; i++) {
            n->children[i]->index_in_siblings = i; // Store index for sibling logic
            enqueue(&q, n->children[i]);
        }
    }

    printf("\n%-10s %-20s %-10s %-10s\n", "Index", "Symbol", "Father", "Sibling");
    printf("-------------------------------------------------------\n");

    // BFS again to print
    init_queue(&q);
    enqueue(&q, root);
    while(!is_empty(&q)) {
        Node* n = dequeue(&q);
        
        int father_id = (n->parent) ? n->parent->id : 0;
        int sibling_id = 0;
        
        if (n->parent) {
            int my_idx = n->index_in_siblings;
            if (my_idx + 1 < n->parent->child_count) {
                sibling_id = n->parent->children[my_idx + 1]->id;
            }
        }
        
        printf("%-10d %-20s %-10d %-10d\n", n->id, n->symbol, father_id, sibling_id);
        
        for(int i=0; i<n->child_count; i++) {
            enqueue(&q, n->children[i]);
        }
    }
}

/* --- MAIN HELPERS --- */

int read_file_content(const char* filename, char** buffer) {
    FILE* f = fopen(filename, "r");
    if (!f) return 0;
    
    char line[MAX_LINE];
    int count = 0;
    while(fscanf(f, "%s", line) == 1) {
        buffer[count] = (char*)malloc(MAX_SYM_LEN);
        strcpy(buffer[count++], line);
    }
    fclose(f);
    return count;
}

int read_pif_content(const char* filename, char** buffer) {
    FILE* f = fopen(filename, "r");
    if (!f) return 0;
    
    char line[MAX_LINE];
    int count = 0;
    while(fgets(line, sizeof(line), f)) {
        line[strcspn(line, "\n")] = 0;
        if(strlen(line) == 0) continue;
        
        buffer[count] = (char*)malloc(MAX_SYM_LEN);
        if (strncmp(line, "ID(", 3) == 0) strcpy(buffer[count++], "ID");
        else if (strncmp(line, "CONST(", 6) == 0) strcpy(buffer[count++], "CONST");
        else strcpy(buffer[count++], line);
    }
    fclose(f);
    return count;
}

/* --- MAIN --- */

int main() {
    Grammar g1, g2;
    LL1Gen gen1, gen2;
    char* seq_buffer[MAX_STACK];

    // --- REQUIREMENT 1 ---
    printf("\n========================================\n");
    printf(" REQUIREMENT 1: Seminar Grammar\n");
    printf("========================================\n");

    load_grammar(&g1, "seminar_grammar.txt");
    
    printf(">> Generating FIRST set...\n");
    generate_first(&g1, &gen1);
    printf(">> Generating FOLLOW set...\n");
    generate_follow(&g1, &gen1);
    printf(">> Building Parsing Table...\n");
    build_parsing_table(&g1, &gen1);

    if (gen1.has_conflicts) {
        printf("\n[RESULT] The Seminar Grammar is NOT LL(1). Conflicts found.\n");
    } else {
        printf("\n[RESULT] The Seminar Grammar IS LL(1).\n");
    }

    int seq_len = read_file_content("seq.txt", seq_buffer);
    int* res1 = parse(&g1, &gen1, seq_buffer, seq_len);
    
    if (res1) {
        printf("Parsed successfully! Productions: ");
        for(int i=0; res1[i] != -1; i++) printf("%d ", res1[i]);
        printf("\n");
    }

    // Cleanup buffer
    for(int i=0; i<seq_len; i++) free(seq_buffer[i]);

    // --- REQUIREMENT 2 ---
    printf("\n========================================\n");
    printf(" REQUIREMENT 2: My DSL Grammar\n");
    printf("========================================\n");

    load_grammar(&g2, "my_grammar.txt");
    
    // Clear sets for gen2
    for(int i=0; i<MAX_SYMBOLS; i++) { gen2.first_set[i].count=0; gen2.follow_set[i].count=0; }
    
    printf(">> Generating FIRST set...\n");
    generate_first(&g2, &gen2);
    printf(">> Generating FOLLOW set...\n");
    generate_follow(&g2, &gen2);
    printf(">> Building Parsing Table...\n");
    build_parsing_table(&g2, &gen2);

    if (gen2.has_conflicts) {
        printf("\n[RESULT] My Grammar had conflicts.\n");
    } else {
        printf("\n[RESULT] My Grammar IS LL(1). No conflicts in parsing table.\n");
    }

    int pif_len = read_pif_content("pif.txt", seq_buffer);
    int* res2 = parse(&g2, &gen2, seq_buffer, pif_len);

    if (res2) {
        int pos = 0;
        Node* root = build_tree_logic(&g2, g2.start_symbol, res2, &pos);
        printf("\n[Req 2.c] Father-Sibling Table:\n");
        print_tree_table(root);
    }
    
    // Cleanup buffer
    for(int i=0; i<pif_len; i++) free(seq_buffer[i]);

    return 0;
}

Here is the C translation of the provided Python code.
This translation maps the Object-Oriented structure of the Python code into C using structs. It uses fixed-size buffers for string handling to keep the code understandable and to avoid complex dynamic memory management issues, which is common practice for academic Compiler Design implementations.
C Implementation (parsing_ll1.c)

C


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* --- CONSTANTS & CONFIGURATION --- */
#define MAX_LINE 512
#define MAX_SYMBOLS 100
#define MAX_SYM_LEN 50
#define MAX_PRODUCTIONS 100
#define MAX_RHS 20
#define MAX_STACK 500
#define EPSILON "epsilon"
#define END_MARKER "$"

/* --- DATA STRUCTURES --- */

// Represents a set of strings (used for NonTerminals, Terminals, First, Follow)
typedef struct {
    char items[MAX_SYMBOLS][MAX_SYM_LEN];
    int count;
} StringSet;

// Represents a single grammar production: A -> X Y Z
typedef struct {
    char lhs[MAX_SYM_LEN];
    char rhs[MAX_RHS][MAX_SYM_LEN];
    int rhs_count;
} Production;

// Represents the Grammar
typedef struct {
    StringSet non_terminals;
    StringSet terminals;
    char start_symbol[MAX_SYM_LEN];
    Production productions[MAX_PRODUCTIONS];
    int prod_count;
} Grammar;

// Represents the LL1 Generator logic
typedef struct {
    StringSet first_set[MAX_SYMBOLS];  // Index corresponds to non_terminals index
    StringSet follow_set[MAX_SYMBOLS]; // Index corresponds to non_terminals index
    
    // Parsing Table: Maps (NonTerm Index, Term Index) -> Production Index (1-based)
    // -1 indicates error/empty
    int table[MAX_SYMBOLS][MAX_SYMBOLS]; 
    bool has_conflicts;
} LL1Gen;

// Tree Node for the output
typedef struct Node {
    char symbol[MAX_SYM_LEN];
    int id;
    struct Node* parent;
    struct Node* children[MAX_RHS];
    int child_count;
    int index_in_siblings; // To help find sibling ID
} Node;

// Queue for BFS (used in printing tree)
typedef struct {
    Node* items[MAX_STACK];
    int front;
    int rear;
} NodeQueue;

/* --- HELPER FUNCTIONS --- */

void error_exit(const char* msg) {
    fprintf(stderr, "Error: %s\n", msg);
    exit(1);
}

// Set operations
void set_add(StringSet* set, const char* val) {
    for (int i = 0; i < set->count; i++) {
        if (strcmp(set->items[i], val) == 0) return;
    }
    strcpy(set->items[set->count++], val);
}

bool set_contains(StringSet* set, const char* val) {
    for (int i = 0; i < set->count; i++) {
        if (strcmp(set->items[i], val) == 0) return true;
    }
    return false;
}

int get_index(StringSet* set, const char* val) {
    for (int i = 0; i < set->count; i++) {
        if (strcmp(set->items[i], val) == 0) return i;
    }
    return -1;
}

void set_union(StringSet* dest, StringSet* src) {
    for (int i = 0; i < src->count; i++) {
        set_add(dest, src->items[i]);
    }
}

// Queue operations
void init_queue(NodeQueue* q) { q->front = 0; q->rear = 0; }
void enqueue(NodeQueue* q, Node* n) { q->items[q->rear++] = n; }
Node* dequeue(NodeQueue* q) { return q->items[q->front++]; }
bool is_empty(NodeQueue* q) { return q->front == q->rear; }

/* --- GRAMMAR FUNCTIONS --- */

void load_grammar(Grammar* g, const char* filename) {
    FILE* f = fopen(filename, "r");
    if (!f) error_exit("Could not open grammar file");

    char line[MAX_LINE];
    bool reading_prods = false;
    g->prod_count = 0;
    g->non_terminals.count = 0;
    g->terminals.count = 0;

    while (fgets(line, sizeof(line), f)) {
        // Trim newline
        line[strcspn(line, "\n")] = 0;
        if (strlen(line) == 0) continue;

        if (strncmp(line, "N =", 3) == 0) {
            char* content = strchr(line, '=') + 1;
            char* token = strtok(content, " ");
            while (token) {
                set_add(&g->non_terminals, token);
                token = strtok(NULL, " ");
            }
        } else if (strncmp(line, "E =", 3) == 0) {
            char* content = strchr(line, '=') + 1;
            char* token = strtok(content, " ");
            while (token) {
                set_add(&g->terminals, token);
                token = strtok(NULL, " ");
            }
        } else if (strncmp(line, "S =", 3) == 0) {
            char* content = strchr(line, '=') + 1;
            while (*content == ' ') content++;
            strcpy(g->start_symbol, content);
        } else if (strncmp(line, "P =", 3) == 0) {
            reading_prods = true;
        } else if (reading_prods && strstr(line, "->")) {
            char* sep = strstr(line, "->");
            *sep = 0; // split string
            char* lhs = line;
            char* rhs = sep + 2;

            // Trim LHS
            while (*lhs == ' ') lhs++;
            char* end = lhs + strlen(lhs) - 1;
            while (end > lhs && *end == ' ') *end-- = 0;

            Production* p = &g->productions[g->prod_count++];
            strcpy(p->lhs, lhs);
            p->rhs_count = 0;

            char* token = strtok(rhs, " ");
            while (token) {
                strcpy(p->rhs[p->rhs_count++], token);
                token = strtok(NULL, " ");
            }
        }
    }

    // Auto-detect terminals not in E but in productions (excluding N and epsilon)
    for (int i = 0; i < g->prod_count; i++) {
        for (int j = 0; j < g->productions[i].rhs_count; j++) {
            char* sym = g->productions[i].rhs[j];
            if (strcmp(sym, EPSILON) != 0 && !set_contains(&g->non_terminals, sym)) {
                set_add(&g->terminals, sym);
            }
        }
    }
    
    // Add $ to terminals for parsing table logic
    set_add(&g->terminals, END_MARKER);
    
    fclose(f);
}

/* --- LL1 GENERATION FUNCTIONS --- */

void compute_first_seq(Grammar* g, LL1Gen* gen, char rhs[][MAX_SYM_LEN], int rhs_len, StringSet* result) {
    if (rhs_len == 0) return;

    char* symbol = rhs[0];

    if (strcmp(symbol, EPSILON) == 0) {
        set_add(result, EPSILON);
    } else if (set_contains(&g->terminals, symbol)) {
        set_add(result, symbol);
    } else if (set_contains(&g->non_terminals, symbol)) {
        int idx = get_index(&g->non_terminals, symbol);
        StringSet* first_of_sym = &gen->first_set[idx];
        
        // Add everything from FIRST(symbol) to result
        for(int k=0; k<first_of_sym->count; k++) {
            set_add(result, first_of_sym->items[k]);
        }

        // If epsilon in FIRST(symbol) and more symbols remain, recurse
        if (set_contains(first_of_sym, EPSILON) && rhs_len > 1) {
            // Remove epsilon temporarily (conceptually) for union, then recurse
            // Note: In strict set logic, we add epsilon only if all parts produce epsilon.
            // But here, if we recurse, we are effectively trying to see what comes next.
            // We just need to ensure 'result' eventually has epsilon only if the whole chain is nullable.
            
            // Re-call with rest of sequence
            // We need a temporary set for the recursive call to check nullability
             // Simplified: if epsilon is in current, we continue.
             // The simple way: Remove epsilon from current result, add result of next.
             // Note: Implementing strictly as per python logic:
             // first_result.remove('epsilon') -> done implicitly by not breaking loop if we handled sets differently, 
             // but here we just added it.
             
             // Correct logic for C translation of Python code:
             // Python: first_result.remove('epsilon'); first_result.update(...)
             // Since we use set_add which doesn't remove, we might have added epsilon.
             // We can't easily "remove" from our array-set without shifting.
             // Instead, let's just be careful. 
             // If we recurse, it means we consumed an epsilon. 
             // The final result has epsilon ONLY if the recursion adds it back.
             
             // Trick: If we are going to recurse, we shouldn't have added epsilon from this symbol yet? 
             // Actually, the Python code adds it, then removes it if len > 1.
             // Let's implement a 'remove' helper or just handle it.
             
             // Simple hack for this specific function:
             // If we are recursing, find epsilon index and decrease count (remove it), then recurse.
             for(int z=0; z<result->count; z++) {
                 if(strcmp(result->items[z], EPSILON) == 0) {
                     // Swap with last and decrease count
                     strcpy(result->items[z], result->items[result->count-1]);
                     result->count--;
                     break;
                 }
             }
             
             // Pass pointer to slice of array? No, simpler to pass new array start logic
             // We can't pass pointer arithmetic on 2D array easily. 
             // We construct a temp array or pass index.
             // Let's pass index + 1.
             // We can't change the signature easily, so let's copy the rest to a temp buffer.
             // (Inefficient but safe).
             char temp_rhs[MAX_RHS][MAX_SYM_LEN];
             for(int c=1; c<rhs_len; c++) strcpy(temp_rhs[c-1], rhs[c]);
             compute_first_seq(g, gen, temp_rhs, rhs_len - 1, result);
        }
    }
}

void generate_first(Grammar* g, LL1Gen* gen) {
    bool change = true;
    while (change) {
        change = false;
        for (int i = 0; i < g->prod_count; i++) {
            Production* p = &g->productions[i];
            int lhs_idx = get_index(&g->non_terminals, p->lhs);
            
            StringSet rhs_first; rhs_first.count = 0;
            compute_first_seq(g, gen, p->rhs, p->rhs_count, &rhs_first);
            
            int original_size = gen->first_set[lhs_idx].count;
            set_union(&gen->first_set[lhs_idx], &rhs_first);
            
            if (gen->first_set[lhs_idx].count > original_size) change = true;
        }
    }
}

void generate_follow(Grammar* g, LL1Gen* gen) {
    int start_idx = get_index(&g->non_terminals, g->start_symbol);
    set_add(&gen->follow_set[start_idx], END_MARKER);

    bool change = true;
    while (change) {
        change = false;
        for (int i = 0; i < g->prod_count; i++) {
            Production* p = &g->productions[i];
            char* lhs = p->lhs;
            int lhs_idx = get_index(&g->non_terminals, lhs);

            for (int j = 0; j < p->rhs_count; j++) {
                char* symbol = p->rhs[j];
                if (set_contains(&g->non_terminals, symbol)) {
                    int sym_idx = get_index(&g->non_terminals, symbol);
                    
                    // Beta is everything after j
                    StringSet beta_first; beta_first.count = 0;
                    // Create temp rhs for beta
                    char beta_rhs[MAX_RHS][MAX_SYM_LEN];
                    int beta_len = 0;
                    for(int k=j+1; k<p->rhs_count; k++) {
                        strcpy(beta_rhs[beta_len++], p->rhs[k]);
                    }
                    compute_first_seq(g, gen, beta_rhs, beta_len, &beta_first);

                    int original_size = gen->follow_set[sym_idx].count;

                    // Add FIRST(beta) - {epsilon}
                    bool epsilon_in_beta = false;
                    for(int k=0; k<beta_first.count; k++) {
                        if(strcmp(beta_first.items[k], EPSILON) == 0) epsilon_in_beta = true;
                        else set_add(&gen->follow_set[sym_idx], beta_first.items[k]);
                    }

                    if (beta_len == 0 || epsilon_in_beta) {
                        set_union(&gen->follow_set[sym_idx], &gen->follow_set[lhs_idx]);
                    }

                    if (gen->follow_set[sym_idx].count > original_size) change = true;
                }
            }
        }
    }
}

void build_parsing_table(Grammar* g, LL1Gen* gen) {
    // Initialize table with -1
    for(int i=0; i<MAX_SYMBOLS; i++)
        for(int j=0; j<MAX_SYMBOLS; j++)
            gen->table[i][j] = -1;
            
    gen->has_conflicts = false;

    for (int i = 0; i < g->prod_count; i++) {
        Production* p = &g->productions[i];
        int lhs_idx = get_index(&g->non_terminals, p->lhs);
        
        StringSet first_alpha; first_alpha.count = 0;
        compute_first_seq(g, gen, p->rhs, p->rhs_count, &first_alpha);
        
        bool epsilon_in_first = false;
        for(int k=0; k<first_alpha.count; k++) {
            char* terminal = first_alpha.items[k];
            if(strcmp(terminal, EPSILON) == 0) {
                epsilon_in_first = true;
                continue;
            }
            
            int term_idx = get_index(&g->terminals, terminal);
            if (term_idx == -1) continue; // Should not happen

            if (gen->table[lhs_idx][term_idx] != -1 && gen->table[lhs_idx][term_idx] != i + 1) {
                printf("  [CONFLICT] Table[%s, %s]: Prod %d vs Prod %d\n", p->lhs, terminal, gen->table[lhs_idx][term_idx], i+1);
                gen->has_conflicts = true;
            } else {
                gen->table[lhs_idx][term_idx] = i + 1;
            }
        }

        if (epsilon_in_first) {
            StringSet* follow = &gen->follow_set[lhs_idx];
            for(int k=0; k<follow->count; k++) {
                char* terminal = follow->items[k];
                int term_idx = get_index(&g->terminals, terminal);
                 if (term_idx == -1) continue;

                if (gen->table[lhs_idx][term_idx] != -1 && gen->table[lhs_idx][term_idx] != i + 1) {
                    printf("  [CONFLICT] Table[%s, %s] (via Follow): Prod %d vs Prod %d\n", p->lhs, terminal, gen->table[lhs_idx][term_idx], i+1);
                    gen->has_conflicts = true;
                } else {
                    gen->table[lhs_idx][term_idx] = i + 1;
                }
            }
        }
    }
}

/* --- PARSER --- */

// Returns dynamic array of ints (production indices), ends with -1
int* parse(Grammar* g, LL1Gen* gen, char** input_seq, int input_len) {
    // Input Stack (Simulated by index in input_seq)
    // Actually, we need to append '$' to input.
    char* input_stack[MAX_STACK];
    for(int i=0; i<input_len; i++) input_stack[i] = input_seq[i];
    input_stack[input_len] = END_MARKER;
    int input_idx = 0;

    // Working Stack
    char* work_stack[MAX_STACK];
    int work_top = 0;
    work_stack[work_top++] = END_MARKER; // Bottom
    work_stack[work_top++] = g->start_symbol; // Top

    // Output
    static int output_prods[MAX_STACK]; // Static buffer for return
    int out_count = 0;

    while (true) {
        char* top_input = input_stack[input_idx];
        char* top_work = work_stack[work_top - 1];

        if (strcmp(top_input, END_MARKER) == 0 && strcmp(top_work, END_MARKER) == 0) {
            output_prods[out_count] = -1; // Terminator
            return output_prods;
        }

        if (strcmp(top_work, top_input) == 0) {
            input_idx++;
            work_top--; // Pop
        } else {
            // It must be a non-terminal
            int nt_idx = get_index(&g->non_terminals, top_work);
            int t_idx = get_index(&g->terminals, top_input);

            if (nt_idx == -1 || t_idx == -1) {
                printf("ERROR: Invalid symbol lookup: Work=%s, Input=%s\n", top_work, top_input);
                return NULL;
            }

            int prod_idx = gen->table[nt_idx][t_idx];
            if (prod_idx == -1) {
                printf("ERROR: Syntax Error at token '%s'. Expected from '%s'\n", top_input, top_work);
                return NULL;
            }

            output_prods[out_count++] = prod_idx;
            Production* p = &g->productions[prod_idx - 1];
            
            work_top--; // Pop LHS
            
            if (strcmp(p->rhs[0], EPSILON) != 0) {
                // Push RHS in reverse
                for (int k = p->rhs_count - 1; k >= 0; k--) {
                    work_stack[work_top++] = p->rhs[k];
                }
            }
        }
    }
}

/* --- TREE BUILDER --- */

// Recursive helper that consumes the iterator (int ptr)
Node* recursive_build_tree(Grammar* g, char* symbol, int* prod_indices_iter) {
    Node* node = (Node*)malloc(sizeof(Node));
    strcpy(node->symbol, symbol);
    node->child_count = 0;
    node->parent = NULL;
    node->id = 0;
    
    if (set_contains(&g->terminals, symbol) || strcmp(symbol, EPSILON) == 0) {
        return node;
    }

    // Must be non-terminal, consume production
    int prod_idx = *prod_indices_iter;
    *prod_indices_iter = *(prod_indices_iter + 1); // Move pointer? No, array logic.
    // In C, we passed the pointer to the CURRENT position in array. 
    // We need to advance the value the pointer points to? No, pointer to current element.
    // Actually simpler: pass int* current_idx, and access array globally or pass array.
    // Let's refactor signature later. For now, assume prod_indices_iter points to current int in array.
    
    // Actually, let's fix the call:
    // We need to advance the stream. 
    // If we just dereference, we get value. We need to increment the pointer for the NEXT call.
    // BUT, recursive_build is called inside the loop.
    
    // Better signature: Node* build(..., int* prods, int* current_pos)
    return NULL; // Placeholder
}

Node* build_tree_logic(Grammar* g, char* symbol, int* prods, int* pos) {
    Node* node = (Node*)malloc(sizeof(Node));
    strcpy(node->symbol, symbol);
    node->child_count = 0;
    node->parent = NULL;

    if (set_contains(&g->terminals, symbol) || strcmp(symbol, EPSILON) == 0) {
        return node;
    }
    
    int prod_idx = prods[*pos];
    (*pos)++; // Consume
    
    Production* p = &g->productions[prod_idx - 1];
    
    if (strcmp(p->rhs[0], EPSILON) == 0) {
        Node* child = (Node*)malloc(sizeof(Node));
        strcpy(child->symbol, EPSILON);
        child->child_count = 0; 
        child->parent = node;
        node->children[node->child_count++] = child;
    } else {
        for(int i=0; i<p->rhs_count; i++) {
            Node* child = build_tree_logic(g, p->rhs[i], prods, pos);
            child->parent = node;
            node->children[node->child_count++] = child;
        }
    }
    return node;
}

void print_tree_table(Node* root) {
    // BFS to assign IDs
    NodeQueue q; init_queue(&q);
    enqueue(&q, root);
    int idx = 1;
    
    while(!is_empty(&q)) {
        Node* n = dequeue(&q);
        n->id = idx++;
        for(int i=0; i<n->child_count; i++) {
            n->children[i]->index_in_siblings = i; // Store index for sibling logic
            enqueue(&q, n->children[i]);
        }
    }

    printf("\n%-10s %-20s %-10s %-10s\n", "Index", "Symbol", "Father", "Sibling");
    printf("-------------------------------------------------------\n");

    // BFS again to print
    init_queue(&q);
    enqueue(&q, root);
    while(!is_empty(&q)) {
        Node* n = dequeue(&q);
        
        int father_id = (n->parent) ? n->parent->id : 0;
        int sibling_id = 0;
        
        if (n->parent) {
            int my_idx = n->index_in_siblings;
            if (my_idx + 1 < n->parent->child_count) {
                sibling_id = n->parent->children[my_idx + 1]->id;
            }
        }
        
        printf("%-10d %-20s %-10d %-10d\n", n->id, n->symbol, father_id, sibling_id);
        
        for(int i=0; i<n->child_count; i++) {
            enqueue(&q, n->children[i]);
        }
    }
}

/* --- MAIN HELPERS --- */

int read_file_content(const char* filename, char** buffer) {
    FILE* f = fopen(filename, "r");
    if (!f) return 0;
    
    char line[MAX_LINE];
    int count = 0;
    while(fscanf(f, "%s", line) == 1) {
        buffer[count] = (char*)malloc(MAX_SYM_LEN);
        strcpy(buffer[count++], line);
    }
    fclose(f);
    return count;
}

int read_pif_content(const char* filename, char** buffer) {
    FILE* f = fopen(filename, "r");
    if (!f) return 0;
    
    char line[MAX_LINE];
    int count = 0;
    while(fgets(line, sizeof(line), f)) {
        line[strcspn(line, "\n")] = 0;
        if(strlen(line) == 0) continue;
        
        buffer[count] = (char*)malloc(MAX_SYM_LEN);
        if (strncmp(line, "ID(", 3) == 0) strcpy(buffer[count++], "ID");
        else if (strncmp(line, "CONST(", 6) == 0) strcpy(buffer[count++], "CONST");
        else strcpy(buffer[count++], line);
    }
    fclose(f);
    return count;
}

/* --- MAIN --- */

int main() {
    Grammar g1, g2;
    LL1Gen gen1, gen2;
    char* seq_buffer[MAX_STACK];

    // --- REQUIREMENT 1 ---
    printf("\n========================================\n");
    printf(" REQUIREMENT 1: Seminar Grammar\n");
    printf("========================================\n");

    load_grammar(&g1, "seminar_grammar.txt");
    
    printf(">> Generating FIRST set...\n");
    generate_first(&g1, &gen1);
    printf(">> Generating FOLLOW set...\n");
    generate_follow(&g1, &gen1);
    printf(">> Building Parsing Table...\n");
    build_parsing_table(&g1, &gen1);

    if (gen1.has_conflicts) {
        printf("\n[RESULT] The Seminar Grammar is NOT LL(1). Conflicts found.\n");
    } else {
        printf("\n[RESULT] The Seminar Grammar IS LL(1).\n");
    }

    int seq_len = read_file_content("seq.txt", seq_buffer);
    int* res1 = parse(&g1, &gen1, seq_buffer, seq_len);
    
    if (res1) {
        printf("Parsed successfully! Productions: ");
        for(int i=0; res1[i] != -1; i++) printf("%d ", res1[i]);
        printf("\n");
    }

    // Cleanup buffer
    for(int i=0; i<seq_len; i++) free(seq_buffer[i]);

    // --- REQUIREMENT 2 ---
    printf("\n========================================\n");
    printf(" REQUIREMENT 2: My DSL Grammar\n");
    printf("========================================\n");

    load_grammar(&g2, "my_grammar.txt");
    
    // Clear sets for gen2
    for(int i=0; i<MAX_SYMBOLS; i++) { gen2.first_set[i].count=0; gen2.follow_set[i].count=0; }
    
    printf(">> Generating FIRST set...\n");
    generate_first(&g2, &gen2);
    printf(">> Generating FOLLOW set...\n");
    generate_follow(&g2, &gen2);
    printf(">> Building Parsing Table...\n");
    build_parsing_table(&g2, &gen2);

    if (gen2.has_conflicts) {
        printf("\n[RESULT] My Grammar had conflicts.\n");
    } else {
        printf("\n[RESULT] My Grammar IS LL(1). No conflicts in parsing table.\n");
    }

    int pif_len = read_pif_content("pif.txt", seq_buffer);
    int* res2 = parse(&g2, &gen2, seq_buffer, pif_len);

    if (res2) {
        int pos = 0;
        Node* root = build_tree_logic(&g2, g2.start_symbol, res2, &pos);
        printf("\n[Req 2.c] Father-Sibling Table:\n");
        print_tree_table(root);
    }
    
    // Cleanup buffer
    for(int i=0; i<pif_len; i++) free(seq_buffer[i]);

    return 0;
}


Instructions for Use
Save the file: Save the code above as parsing_ll1.c.
Input Files: Ensure you have the same text files in the directory as required by the Python script:
seminar_grammar.txt
seq.txt
my_grammar.txt
pif.txt
Compile: Open your terminal and run:
Bash
gcc parsing_ll1.c -o parser


Run:
Bash
./parser


Key Translation Notes
Structs: Classes like Grammar, LL1Gen, and Node are converted to struct.
Memory: Instead of Python's dynamic lists, this C code uses fixed-size arrays (e.g., MAX_SYMBOLS) for simplicity and reliability in an academic context.
Sets: A StringSet struct and helper functions (set_add, set_union) replicate Python's set() functionality.
Logic: The logic for FIRST/FOLLOW, parsing table generation, and tree building remains algorithmically identical to the Python version.


COMPARISON: Manual C Parser vs. Yacc/Bison Parser

1. PARSING STRATEGY
-------------------
Manual C (Recursive Descent):
- Top-Down (LL): Starts with the highest-level rule (Start Symbol) and attempts to predict which lower-level rule to apply next based on the current input token.
- Explicit Control Flow: Uses C functions to represent grammar rules (e.g., `parse_program()`, `parse_statement()`). The execution stack of the C program mirrors the parse tree.

Yacc/Bison (LALR):
- Bottom-Up (LALR): Reads tokens and shifts them onto a stack until a pattern matches a rule (a "handle"), then reduces them to a non-terminal.
- Table-Driven: Uses a pre-generated state transition table (state machine) to decide whether to shift or reduce, rather than recursive function calls.

2. GRAMMAR CONSTRAINTS
----------------------
Manual C:
- Strict LL(1): The grammar must be free of left recursion (e.g., `A -> A + B` is forbidden and causes infinite loops).
- No Ambiguity: You must manually resolve conflicts where two rules could apply to the same input token.

Yacc/Bison:
- Flexible (LALR): Can handle left-recursive grammars naturally, which is often more intuitive for mathematical expressions.
- Operator Precedence: Handles ambiguity (like order of operations) automatically using directives like `%left` and `%right` (as seen in your `vect_matrix_ops.y` file), without needing to rewrite the grammar structure.

DEF theorem_check(A, B)
BEGIN
    L = (A & B) T
    R = (B T) * (A T)
    IF L == R THEN
        RETURN 1
    ELSE
        RETURN 0
    END
END

M1 = MATRIX([[1, 2], [3, 4]])
M2 = MATRIX([[5, 6], [7, 8]])
OUTPUT theorem_check(M1, M2)

yacc: Lexical error at line 3: unexpected character '&'
        Syntax error at line 3 near '&': syntax error, unexpected end of file, expecting RPAREN
        Syntactically correct: NO
c: [RESULT] My Grammar IS LL(1). No conflicts in parsing table.
    ERROR: Invalid symbol lookup: Work=id_tail, Input=&

DEF theorem_check(A, B)
BEGIN
    L = (A * B) T
    R = (B T) * (A T)
    IF L == R THEN
        RETURN 1
    ELSE
        RETURN 0
    END
END

yacc: Syntactically correct: YES
c: [RESULT] My Grammar IS LL(1). No conflicts in parsing table.

[Req 2.c] Father-Sibling Table:

Index      Symbol               Father     Sibling   
-------------------------------------------------------
1          program              0          0         
2          statement_list       1          0         
3          statement            2          4         
4          statement_list       2          0         
5          def_stmt             3          0         
6          statement            4          7         
7          statement_list       4          0         
8          DEF                  5          9         
9          ID                   5          10        
10         (                    5          11        
11         parameters_opt       5          12        
12         )                    5          13        
13         BEGIN                5          14        
14         statement_list       5          15        
15         END                  5          0         
16         assign_or_expr       6          0         
17         statement            7          18        
18         statement_list       7          0         
19         parameters           11         0         
20         statement            14         21        
21         statement_list       14         0         
22         ID                   16         23        
23         id_processing        16         0         
24         assign_or_expr       17         0         
25         statement            18         26        
26         statement_list       18         0         
27         ID                   19         28        
28         parameters_tail      19         0         
29         assign_or_expr       20         0         
30         statement            21         31        
31         statement_list       21         0         
32         =                    23         33        
33         expression           23         0         
34         ID                   24         35        
35         id_processing        24         0         
36         output_stmt          25         0         
37         epsilon              26         0         
38         ,                    28         39        
39         ID                   28         40        
40         parameters_tail      28         0         
41         ID                   29         42        
42         id_processing        29         0         
43         assign_or_expr       30         0         
44         statement            31         45        
45         statement_list       31         0         
46         term                 33         47        
47         expression_rest      33         0         
48         =                    35         49        
49         expression           35         0         
50         OUTPUT               36         51        
51         expression           36         52        
52         expression_tail      36         0         
53         epsilon              40         0         
54         =                    42         55        
55         expression           42         0         
56         ID                   43         57        
57         id_processing        43         0         
58         if_stmt              44         0         
59         epsilon              45         0         
60         base_term            46         61        
61         postfix_opt          46         0         
62         epsilon              47         0         
63         term                 49         64        
64         expression_rest      49         0         
65         term                 51         66        
66         expression_rest      51         0         
67         epsilon              52         0         
68         term                 55         69        
69         expression_rest      55         0         
70         =                    57         71        
71         expression           57         0         
72         IF                   58         73        
73         condition            58         74        
74         THEN                 58         75        
75         statement_list       58         76        
76         else_part            58         77        
77         END                  58         0         
78         non_id_base_term     60         0         
79         epsilon              61         0         
80         base_term            63         81        
81         postfix_opt          63         0         
82         epsilon              64         0         
83         base_term            65         84        
84         postfix_opt          65         0         
85         epsilon              66         0         
86         base_term            68         87        
87         postfix_opt          68         0         
88         epsilon              69         0         
89         term                 71         90        
90         expression_rest      71         0         
91         expression           73         92        
92         comparator           73         93        
93         expression           73         0         
94         statement            75         95        
95         statement_list       75         0         
96         ELSE                 76         97        
97         statement_list       76         0         
98         MATRIX               78         99        
99         (                    78         100       
100        matrix_rows          78         101       
101        )                    78         0         
102        non_id_base_term     80         0         
103        epsilon              81         0         
104        ID                   83         105       
105        id_tail              83         0         
106        epsilon              84         0         
107        non_id_base_term     86         0         
108        T                    87         0         
109        base_term            89         110       
110        postfix_opt          89         0         
111        *                    90         112       
112        term                 90         113       
113        expression_rest      90         0         
114        term                 91         115       
115        expression_rest      91         0         
116        ==                   92         0         
117        term                 93         118       
118        expression_rest      93         0         
119        return_stmt          94         0         
120        epsilon              95         0         
121        statement            97         122       
122        statement_list       97         0         
123        [                    100        124       
124        vector_elements      100        125       
125        ]                    100        126       
126        matrix_row_tail      100        0         
127        MATRIX               102        128       
128        (                    102        129       
129        matrix_rows          102        130       
130        )                    102        0         
131        (                    105        132       
132        arguments_opt        105        133       
133        )                    105        0         
134        (                    107        135       
135        expression           107        136       
136        )                    107        0         
137        non_id_base_term     109        0         
138        epsilon              110        0         
139        base_term            112        140       
140        postfix_opt          112        0         
141        epsilon              113        0         
142        base_term            114        143       
143        postfix_opt          114        0         
144        epsilon              115        0         
145        base_term            117        146       
146        postfix_opt          117        0         
147        epsilon              118        0         
148        RETURN               119        149       
149        expression           119        0         
150        return_stmt          121        0         
151        epsilon              122        0         
152        expression           124        153       
153        vector_tail          124        0         
154        epsilon              126        0         
155        [                    129        156       
156        vector_elements      129        157       
157        ]                    129        158       
158        matrix_row_tail      129        0         
159        arguments            132        0         
160        term                 135        161       
161        expression_rest      135        0         
162        (                    137        163       
163        expression           137        164       
164        )                    137        0         
165        non_id_base_term     139        0         
166        epsilon              140        0         
167        ID                   142        168       
168        id_tail              142        0         
169        epsilon              143        0         
170        ID                   145        171       
171        id_tail              145        0         
172        epsilon              146        0         
173        term                 149        174       
174        expression_rest      149        0         
175        RETURN               150        176       
176        expression           150        0         
177        term                 152        178       
178        expression_rest      152        0         
179        ,                    153        180       
180        expression           153        181       
181        vector_tail          153        0         
182        expression           156        183       
183        vector_tail          156        0         
184        epsilon              158        0         
185        expression           159        186       
186        arguments_tail       159        0         
187        base_term            160        188       
188        postfix_opt          160        0         
189        *                    161        190       
190        term                 161        191       
191        expression_rest      161        0         
192        term                 163        193       
193        expression_rest      163        0         
194        (                    165        195       
195        expression           165        196       
196        )                    165        0         
197        epsilon              168        0         
198        epsilon              171        0         
199        base_term            173        200       
200        postfix_opt          173        0         
201        epsilon              174        0         
202        term                 176        203       
203        expression_rest      176        0         
204        base_term            177        205       
205        postfix_opt          177        0         
206        epsilon              178        0         
207        term                 180        208       
208        expression_rest      180        0         
209        epsilon              181        0         
210        term                 182        211       
211        expression_rest      182        0         
212        ,                    183        213       
213        expression           183        214       
214        vector_tail          183        0         
215        term                 185        216       
216        expression_rest      185        0         
217        ,                    186        218       
218        expression           186        219       
219        arguments_tail       186        0         
220        ID                   187        221       
221        id_tail              187        0         
222        epsilon              188        0         
223        base_term            190        224       
224        postfix_opt          190        0         
225        epsilon              191        0         
226        base_term            192        227       
227        postfix_opt          192        0         
228        epsilon              193        0         
229        term                 195        230       
230        expression_rest      195        0         
231        non_id_base_term     199        0         
232        epsilon              200        0         
233        base_term            202        234       
234        postfix_opt          202        0         
235        epsilon              203        0         
236        non_id_base_term     204        0         
237        epsilon              205        0         
238        base_term            207        239       
239        postfix_opt          207        0         
240        epsilon              208        0         
241        base_term            210        242       
242        postfix_opt          210        0         
243        epsilon              211        0         
244        term                 213        245       
245        expression_rest      213        0         
246        epsilon              214        0         
247        base_term            215        248       
248        postfix_opt          215        0         
249        epsilon              216        0         
250        term                 218        251       
251        expression_rest      218        0         
252        epsilon              219        0         
253        epsilon              221        0         
254        ID                   223        255       
255        id_tail              223        0         
256        epsilon              224        0         
257        ID                   226        258       
258        id_tail              226        0         
259        T                    227        0         
260        base_term            229        261       
261        postfix_opt          229        0         
262        epsilon              230        0         
263        CONST                231        0         
264        non_id_base_term     233        0         
265        epsilon              234        0         
266        [                    236        267       
267        vector_elements      236        268       
268        ]                    236        0         
269        non_id_base_term     238        0         
270        epsilon              239        0         
271        non_id_base_term     241        0         
272        epsilon              242        0         
273        base_term            244        274       
274        postfix_opt          244        0         
275        epsilon              245        0         
276        ID                   247        277       
277        id_tail              247        0         
278        epsilon              248        0         
279        base_term            250        280       
280        postfix_opt          250        0         
281        epsilon              251        0         
282        epsilon              255        0         
283        epsilon              258        0         
284        ID                   260        285       
285        id_tail              260        0         
286        T                    261        0         
287        CONST                264        0         
288        expression           267        289       
289        vector_tail          267        0         
290        [                    269        291       
291        vector_elements      269        292       
292        ]                    269        0         
293        [                    271        294       
294        vector_elements      271        295       
295        ]                    271        0         
296        non_id_base_term     273        0         
297        epsilon              274        0         
298        epsilon              277        0         
299        ID                   279        300       
300        id_tail              279        0         
301        epsilon              280        0         
302        epsilon              285        0         
303        term                 288        304       
304        expression_rest      288        0         
305        ,                    289        306       
306        expression           289        307       
307        vector_tail          289        0         
308        expression           291        309       
309        vector_tail          291        0         
310        expression           294        311       
311        vector_tail          294        0         
312        [                    296        313       
313        vector_elements      296        314       
314        ]                    296        0         
315        epsilon              300        0         
316        base_term            303        317       
317        postfix_opt          303        0         
318        epsilon              304        0         
319        term                 306        320       
320        expression_rest      306        0         
321        epsilon              307        0         
322        term                 308        323       
323        expression_rest      308        0         
324        ,                    309        325       
325        expression           309        326       
326        vector_tail          309        0         
327        term                 310        328       
328        expression_rest      310        0         
329        ,                    311        330       
330        expression           311        331       
331        vector_tail          311        0         
332        expression           313        333       
333        vector_tail          313        0         
334        non_id_base_term     316        0         
335        epsilon              317        0         
336        base_term            319        337       
337        postfix_opt          319        0         
338        epsilon              320        0         
339        base_term            322        340       
340        postfix_opt          322        0         
341        epsilon              323        0         
342        term                 325        343       
343        expression_rest      325        0         
344        epsilon              326        0         
345        base_term            327        346       
346        postfix_opt          327        0         
347        epsilon              328        0         
348        term                 330        349       
349        expression_rest      330        0         
350        epsilon              331        0         
351        term                 332        352       
352        expression_rest      332        0         
353        ,                    333        354       
354        expression           333        355       
355        vector_tail          333        0         
356        CONST                334        0         
357        non_id_base_term     336        0         
358        epsilon              337        0         
359        non_id_base_term     339        0         
360        epsilon              340        0         
361        base_term            342        362       
362        postfix_opt          342        0         
363        epsilon              343        0         
364        non_id_base_term     345        0         
365        epsilon              346        0         
366        base_term            348        367       
367        postfix_opt          348        0         
368        epsilon              349        0         
369        base_term            351        370       
370        postfix_opt          351        0         
371        epsilon              352        0         
372        term                 354        373       
373        expression_rest      354        0         
374        epsilon              355        0         
375        CONST                357        0         
376        CONST                359        0         
377        non_id_base_term     361        0         
378        epsilon              362        0         
379        CONST                364        0         
380        non_id_base_term     366        0         
381        epsilon              367        0         
382        non_id_base_term     369        0         
383        epsilon              370        0         
384        base_term            372        385       
385        postfix_opt          372        0         
386        epsilon              373        0         
387        CONST                377        0         
388        CONST                380        0         
389        CONST                382        0         
390        non_id_base_term     384        0         
391        epsilon              385        0         
392        CONST                390        0